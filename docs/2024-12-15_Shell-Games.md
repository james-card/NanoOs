# 2024-12-15 - Shell Games

I spent about a day and a half after my last post developing a shell process that could launch a new process.  The first thing I had to figure out was how the shell would spawn a new process in such a way that it could take ownership of the console that the shell was using.  It obviously didn't make any sense for more than one process to be connected to stdin at a time, so working out this transfer was the first major hill to get over.

At the time, there were three (3) "kernel" processes that provided services to the the commands:  The scheduler, the console, and the memory manager.  Up until the introduction of the shell, the console had direclty parsed and launched commands.  With the shell, that would no longer be true.  The shell would be a user process, not a kernel process.  So, now there would be a user process - which would consume one of the user process slots - launching another user process.

Even with the console directly parsing command lines, it still didn't actually launch processes.  Only the scheduler can do that.  So, the console would send a message to the scheduler with the information about how to launch the process.  The shell will do the same thing.  However, this was a non-blocking message from the console.  A shell will need to assign ownership of the console port it was using to the launched process and then wait for that process to complete before resuming reading input from the port.

In modern operating systems, the shell always launches a new process when a command is run (unless it's a built-in command).  Early versions of UNIX, however, didn't work that way.  Due to memory constraints, what they did was to replace the running shell with the process being launched.  They basically wrote a small bootloader that would load in the next executable.  When that program completed, the bootloader would run again and reload the shell.  It took the authors a while to figure out how to do that and still maintain the environmental state that needed to persist across program loads.

With the console parsing command lines and launching processes, it could always launch the command as a new process.  However, there was a problem I ran into early on about what happens when all available process slots are consumed.  In that case, there's no way to launch process management commands like `ps` and `kill`.  The way I had dealt with this was to always have one process slot reserved for these kinds of commands.

So, there was a question about the best way for my shell to launch processes.  This is an embedded OS and process slots are extremely limited.  As I've mentioned before, it can currently only support up to eight (8) processes and three (3) of those are taken by kernel processes.  With the one reserved process slot, that left four (4) slots open for general user commands and one (1) for special commands.  The shell is considered a user process and my ultimate goal is to support multiple concurrent shells, so I was faced with ultimately consuming at least two (2) process slots for shell processes.

If the shell continued to launch a new process for all user commands, then, with two shells running in parallel, there would only be enough slots to run one general user command per shell.  Not much of a multitasking OS environment in that kind of situation.  Also, the fact that there was only one reserved slot for process management commands meant that only one user could run such a command at a time, which is a poor - if not outright dangerous - design.

I clearly needed a better design.  One possibility would be to go back to the way early versions of UNIX did things and always replace the shell with the new command to run.  However, I didn't like that idea for two reasons:  (1) it's not realistic and not representative of how modern operating systems work and (2) it removes the possibility of having background processes running.  It would also essentially mean that all other process slots were wasted, although I could potentially just use the memory for the extra slots for the dynamic memory manager.

Then I had a realization:  I could use a hybrid approach.  I could make process management commands replace the running shell and all other commands be launched as new processes.  This approach had the additional benefit that it eliminated the need to reserve a process slot for the process management functions.  Since they would replace the running shell process, they would always be guaranteed to have an available process slot to run in.  So, in five (5) user process slots with two (2) concurrent shells, there would be three (3) available process slots for any general user commands to run in.  Still not super, but better, and not terrible for an embedded OS.


