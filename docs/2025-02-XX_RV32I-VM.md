# XX-Feb-2025 - RV32I VM

I spent about a day working with [Claude](https://claude.ai) on a VM for the RV32I instruction set architecture.  It was at least an order of magnitude simpler than trying to implement a VM for WASM.  There are really only two memory segments to manage:  Physical Memory and Mapped Memory.  Of that, only physical memory was super critical.  I do have to be able to handle both in the VM eventually, but most of what's needed only requires physical memory.  On top of that, there wound up only being 10 opcodes that I needed to support for the base implementation.

After doing a little research on how RV32I programs are organized, I realized that I was going to need a way to copy one virtual block of virtual memory to another.  The reason for this was that, unlike the WASM programs, the standard base address of RV32I programs is 0x1000, not 0.  So, I needed to copy the RV32I binary to address 0x1000 of the physical memory segment.

Because all virtual memory is backed by files, this meant that I needed a new function to copy the contents of a piece of one file into another file.  Then I stopped to think about this...  Why isn't there a function to do this in the C standard?  There are functions to read a file, write (and by extension, create) a file, rename (and by extension, move) a file, and delete a file.  Why, in the 50+ years of the language's existence, haven't we added a function to copy contents of one file to another?  Meh.  Well, it doesn't exist, so I had to create something.

This turned out to be a bit of a problem.  In an application, it would be pretty straightforward:  Declare a buffer one block in size for each file, read one block into the destination file's buffer from the destination offset, read one block into the source file's buffer from the source offset, copy the piece of the source you need into the appropriate location in the destination, then write the destination block back out.  Lather, rinse, and repeat until you copy all the data you need.

In an embedded environment, this won't work.  I **MIGHT** have enough RAM to store two buffers, but I really can't count on that.  I can really only expect to have one buffer to work with.  This means I have to use the same buffer for both reads and writes.  That, in turn, means that I have to copy multiples of blocks and that the offsets have to be block aligned.  This, however, is not really a big deal for what I'm doing.  Since I'm copying an entire file, I just read a block from the source and then write it to the destination.  If the length of the source file isn't block aligned, it makes no difference.  So, I made a function in the filesystem process to do just that.  Making the wrapper function in the virtual memory library was trivial.

New virtual memory functionality in place, I wrote code to initialize the physical memory segment and copy a specified RV32I-compiled executable file into the appropriate offset of the physical memory segment.  So far so good.  At this point, I still had a little over 10% of the program flash available on the Nano Every.  Time to start putting in handlers for instructions.

This was a job for Claude.  I did not want to put all the case statements in place for this.  I'll spare you the details on this one, but it took some "coaching" on my part to get it to make something useful.  It's first take on it was to put every handler for every opcode and every subfucntion inline in one giant switch statement.  There were multiple levels of switch statements.  It also didn't use defines or enums for any of the values, so everything used hardcoded magic numbers.  Bad call.

Anyway, once I finally got all the opcode handler logic in place, it was time to compile it and see what happened.  To my great surprise, it actually fit in the available space!  Hooray!!!  OK!  Time to figure out how to make this thing do something useful!  How about a "Hello world" program, Claude?

So, I asked Claude how an RV32I-compiled program would print out a string.  Its answer was... less than desirable.  The RV32I side it produced was fine.  However, part of its answer was to extend one of the handlers that it had previously produced.  It seems that in the case of the instruction that was needed here (SYSTEM ECALL) it had just returned rather than actually handling the instruction.  So, I had to add in the piece that it had skipped over earlier.  And, to probably nobody's surprise, adding that code pushed the total binary size over the flash size.

But, not by much.  Close enough that I thought I might be able to identify some functionality I could cut and get back within the limit.  The first thing I did was remove all the code that was still related to the old way of running processes.  Better, but not good enough.  Then, I turned off debugging messages.  Then, I commented out all the error messages in the SD library since it's not really an issue any longer.  Getting close!  Then, I commented out all the prints that happen at boot up.  Not only did that get me under the limit, it got me over 1 KB under the limit!  Enough space to do some cleanup too!  Cool!!!

To be continued...

[Table of Contents](.)


