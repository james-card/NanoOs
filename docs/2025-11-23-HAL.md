# 23-Nov-2025 - "Open the Pod Bay Doors, HAL."

One thing that's bugged me about my OS is that it required a small amount of C++.  I'm great at C, but I'm mediocre at C++.  The main reason for me doing this project was to improve my embedded C skills.  The fact that I've had to use C++ to interface with Arduino's libraries is just a nuisance.  There wasn't a lot of it in the code, but just enough so that all of the main libraries had to be .cpp files instead of .c.  It was just aggravating.

Now, because of the way the Arduino libraries work, it's not possible to completely get away from C++.  It was possible, however, to isolate it.  The only things that I really needed Arduino-specific functionality for was interacting with the hardware.  Everything else was OS or application logic that was completely independent of that.  Since the part that I wanted to isolate was all hardware specific, the solution here was obvious:  Rearchitect the code with a Hardware Abstraction Layer (HAL).

Having a HAL also provides a means to do a few other things I've been wanting to do.  One of the things I've been thinking about is porting NanoOs to a different system - one that isn't Arduino-based.  Having a HAL would allow that to be possible.  I've also been wanting to run it in a simulator as a regular Linux&reg; application.  That would (a) allow my development to go much faster and (b) allow me to write tests and do analysis on the code with proper development tools.  So, with multiple motivating factors before me, I set out to make a proper HAL.

At this point in the life of the project, there was a fair bit to consider, especially if I intended to also be able to run the OS as a regular userspace application.  The basics of abstracting simple IO were pretty straightforward, but more involved things like simulating peripherals and running overlay code out of memory were going to require some thought.  As an old IBM manual said, "Some design may be required."

The first thing I had to consider was how to represent the HAL.  The whole point of this exercise is to require as little change to the core logic as possible in order to support a new environment.  That meant I really needed to think about how the rest of the code was going to interact with it and what the integration points would be.

I did some research on how different modern operating system kernels do hardware abstraction.  The most-famous one is, of course, modern NT-based Windows&reg;.  On Windows&reg;, the HAL is a DLL, which obviously wouldn't work here, but the general of having a single location for a collection of swappable functions, might.  I looked into other operating systems as well.  Somewhat disappointingly, Linux&reg;, which is a monolithic kernel, uses distributed abstractions instead of a monolithic HAL.  Basically, easch subsystem layer is responsible for its own form of hardware abstraction.  The XNU kernel (of macOS&reg;) has something called "I/O Kit", which is a formal, object-oriented framework that manages most hardware abstraction, but not all.  And, of course, microkernels do almost zero hardware management in kernel space, at least in general.  I didn't dig into any one microkernel in detail, but I would suspect that at a basic level, they're either tightly coupled to the hardware or they have some form of small, monolithic abstraction if they intend to be portable.

Anyway, I outright rejected the idea of distributed abstractions since it flew in the face of my goal of isolating the hardware-specific code to a single part of the codebase.  Having processes manage some portion of abstraction the way a microkernel does is inevitable given that my SD card interface is implemented as a process.  For basic functionality, though, I decided to go with a structure of function pointers that are initialized by something outside of the main OS logic (i.e. something that's done before the scheduler is started).  This provided the extra benefit that I could have the HAL hold data as well.  This became important immediately.

Since it was fresh on my mind from my recent work with overlays, the first thing I did was to remove the hardcoded constants for the overlay map and put them into the HAL.  In the new HAL structure, I defined two variables:  A pointer to a NanoOsOverlayMap structure and a size of the overlay.  I created a .cpp file to hold the implementation of the HAL (which has to be C++ because all of the Arduino-specific code will eventually be in there) that had the values set in a static member variable and a `halArduinoNano33IotInit` function that returned a pointer to it.  This would allow me to have different implementations of the HAL just by changing the function that's called to initialize the global HAL pointer.  I then went about changing all the hardcoded constants to reference the member elements of the global HAL pointer.

The next thing I did was to take on serial port initialization.  That was currently being done directly in the root Arduino project file ("NanoOs.ino" in this case).  To make the code more portable, I needed a way to do it in the HAL.  So, I added an `initializeSerialPort` function pointer to the HAL structure, added an `arduinoNano33IotInitializeSerialPort` function to the implementation library, and set the function pointer to the new function in the HAL implementation.  This was the point at which I formally included Arduino-specific code into the HAL.  The serial ports are referenced externally by zero-based integers which map into a static array of pointers to Arduino HardwareSerial objects internally.  I also added a `getNumSerialPorts` function to the HAL that just returned the number of elements in the array.  I changed the code in the `setup` function of the NanoOs.ino file to iterate over the available serial ports and call the `initializeSerialPort` function on each of them.

After that, I took on reading and writing data from/to a serial port.  For the rest of the OS, interactions with the serial ports were abstracted through the Console library, but the Console library itself still directly utilized Arduino-specific functions (and was therefore a C++ file).  I added a `pollSerialPort` function to the HAL that would check for a single character and a `writeSerialPort` function that would write a series of bytes.  I then changed all the existing Arduino-specific code in the Console library to the equivalent logic that used the HAL.  This broke the Console library's dependence on Arduino code and consequently allowed it to be convereted to a pure C library!

The next round of abstraction changes was considerably more-involved.  I needed to break the SD card library's dependence on Arduino code.  The existing SD card implementation relied on SPI, so I would obviously have to abstract the Arduino SPI mechanisms.  However, as should come as no surprise, SPI relies on Arduino's GPIO mechanisms, so I would have to come up with an abstraction for that as well.

I started at the bottom, GPIO, and worked my way upward.  If I was going to do a full HAL implementation, there are six (6) things I would need to implement in addition to getting the number of available GPIOs:  DIO configuration, digital read, digital write, AIO configuration, analog read, and analog write.  *However,* (a) I'm not going for a full implementation and (b) I would have no way to test one.  So, I restricted myself to only getting the number of DIOs (and omitting the number of AIOs), configuring a DIO, and doing a digital write since that's all that my SD card library was using.

Ultimately, the implementation was pretty simple, however I did have to think about how to organize the calls to configure a DIO and write to one.  I made both of them take an integer DIO pin number as their first parameter (which has to begin at 2 because 0 and 1 are used for Serial1 RX and TX, respectively).  For `arduinoNano33IotConfigureDio`, I made the second parameter a boolean that determined whether or not to configure the pin for output and for `arduinoNano33IotWriteDio`, I made the second parameter a boolean that determined whether or not the write was to set the pin high.  Once I had the functions in place, I replaced all the existing calls to the Arduino `pinMode` and `digitalWrite` functions with their HAL equivalents.

[Table of Contents](.)
