# 23-Nov-2025 - "Open the Pod Bay Doors, HAL."

One thing that's bugged me about my OS is that it required a small amount of C++.  I'm great at C, but I'm mediocre at C++.  The main reason for me doing this project was to improve my embedded C skills.  The fact that I've had to use C++ to interface with Arduino's libraries is just a nuisance.  There wasn't a lot of it in the code, but just enough so that all of the main libraries had to be .cpp files instead of .c.  It was just aggravating.

Now, because of the way the Arduino libraries work, it's not possible to completely get away from C++.  It was possible, however, to isolate it.  The only things that I really needed Arduino-specific functionality for was interacting with the hardware.  Everything else was OS or application logic that was completely independent of that.  Since the part that I wanted to isolate was all hardware specific, the solution here was obvious:  Rearchitect the code with a Hardware Abstraction Layer (HAL).

Having a HAL also provides a means to do a few other things I've been wanting to do.  One of the things I've been thinking about is porting NanoOs to a different system - one that isn't Arduino-based.  Having a HAL would allow that to be possible.  I've also been wanting to run it in a simulator as a regular Linux application.  That would (a) allow my development to go much faster and (b) allow me to write tests and do analysis on the code with proper development tools.  So, with multiple motivating factors before me, I set out to make a proper HAL.

At this point in the life of the project, there was a fair bit to consider, especially if I intended to also be able to run the OS as a regular userspace application.  The basics of abstracting simple IO were pretty straightforward, but more involved things like simulating peripherals and running overlay code out of memory were going to require some thought.  As an old IBM manual said, "Some design may be required."

The first thing I had to consider was how to represent the HAL.  The whole point of this exercise is to require as little change to the core logic as possible in order to support a new environment.  That meant I really needed to think about how the rest of the code was going to interact with it and what the integration points would be.

I did some research on how different modern operating system kernels do hardware abstraction.  The most-famous one is, of course, modern NT-based Windows&reg;.  On Windows&reg;, the HAL is a DLL, which obviously wouldn't work here, but the general of having a single location for a collection of swappable functions, might.  I looked into other operating systems as well.  Somewhat disappointingly, Linux&reg;, which is a monolithic kernel, uses distributed abstractions instead of a monolithic HAL.  Basically, easch subsystem layer is responsible for its own form of hardware abstraction.  The XNU kernel (of macOS&reg;) has something called "I/O Kit", which is a formal, object-oriented framework that manages most hardware abstraction, but not all.  And, of course, microkernels do almost zero hardware management in kernel space, at least in general.  I didn't dig into any one microkernel in detail, but I would suspect that at a basic level, they're either tightly coupled to the hardware or they have some form of small, monolithic abstraction if they intend to be portable.

Anyway, I outright rejected the idea of distributed abstractions since it flew in the face of my goal of isolating the hardware-specific code to a single part of the codebase.  Having processes manage some portion of abstraction the way a microkernel does is inevitable given that my SD card interface is implemented as a process.  For basic functionality, though, I decided to go with a structure of function pointers that are initialized by something outside of the main OS logic (i.e. something that's done before the scheduler is started).  This provided the extra benefit that I could have the HAL hold data as well.

[Table of Contents](.)
