# 28-Jan-2025 - WASM VM

Let's first talk about the goal and why I even have it.  The Arduino Nano Every - as well as some other models of Arduino and other systems - is a Harvard architecture.  That means that it's impossible to load executable code into RAM and run it.  Translation:  There is absolutely no way for me to load code compiled for the Nano Every's processor (an ATMEGA4809) and run it natively.  So, if I'm going to run arbitrary commands that are read from the filesystem, my only option is to have something that can translate something in the command file to something that executes.  So, we're talking about a VM here.

One option would be to make a VM for the ATMEGA and compile binaries to that.  But, why?  There's nothing inherently great about that for what I'm doing.  These SD cards are enormous.  Once we're talking about accessing data on the card, the binaries can be basically any size and we don't care.  That's why getting to the point of having a usable filesystem was so important.

My idea was to make a VM for Web Assembly (WASM).  That has the potential to be a universal assembly language.  If I make a VM for that, anything that is compiled to WASM becomes something that my OS can run.  So, that's what I set out to do.

First thing's first:  Delete all the existing command infrastructure.  There were two reasons for this.  First:  I needed the space.  By the time I got done with the SD card and FAT filesystem infrastructure, I only had a little less than 800 bytes of program flash left.  Deleting the existing infrastructure gave me about 8.5 KB to work with.  Second:  It will no longer be relevant.  All of the processes will have to run through the VM and the existing commands just flat out won't even work anymore.  So, get rid of it.

OK, space recovered, I set about trying to make something that can run WASM-compiled code.  One issue with this is that there are multiple WASM formats.  The most popular one right now is called "Emscripten".  Emscripten aims to provide a POSIX-compliant environment that will allow most existing C code to be compiled to WASM with little or no modification.  That would be ideal, however that puts a pretty high burden on the VM developer for providing the necessary environmental functionality.  A competing format is called "WASI" which aims to be the official OS support definition for WASM.  It has simpler environmental requirements than Emscripten does.

Given the limited resources I have to work with, deciding which format to go with was not a super hard decision.  I need to eliminate all the complexity I can to save flash space.  I didn't know going into this how much flash was going to be consumed by either format, but I didn't want to get part way through implementing the larger one and then find out that only the smaller one would fit.  WASI seemed like the safest bet, so that's what I went with.

Now, irrespective of which format is used, there are several things that any WASM VM requires being setup before a program is even started.  In addition to the memory for the code itself, there are five (5) memory segments required by a WASM program:

1. Linear Memory
2. The Global Stack
3. The Call Stack
4. Global Storage
5. Table Space

Each of these things would take up way more RAM than I have available.  So, the first thing I had to do was develop a virtual memory system.  Mind you, this is not virtual memory in the traditional sense of the term.  This is just a way for the VM to access data.  From the standpoint of the VM process, it's virtual memory because the system will fetch whatever data is referenced by the addresses the process references, but there's no page fault or TLB or anything else going on here.  The system looks up data in a file according a provided address and returns whatever is there if it's a read or sets the data if it's a write.

Just having five pieces of virtual memory wasn't enough, though.  They had to be initialized as well.  First, the linear memory had to be allocated.  That was pretty straightforward:  Just write 64 KB of zeros to the virtual memory and you're done.  The stacks were also pretty straightforward:  Just write the value of what would be the stack register to the first 32-bits of the stack and you're done.

There were two areas, however, that required pretty extensive logic:  Function imports and function exports.  WASM doesn't have interrupts.  The way that WASM interacts with the host OS is by listing the functions it will use and then context switching to them via a CALL instruction.  The instructions reference an index into a table of imported functions that's listed near the beginning of the binary.  When the VM starts, it scans the binary for the host functions that the program needs.  It then looks up the inforamtion for those functions within host space and stores its own metadata in the Table Space virtual memory segment.

To be continued...

[Table of Contents](.)

