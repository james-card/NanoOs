////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                     Copyright (c) 2012-2024 James Card                     //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included    //
// in all copies or substantial portions of the Software.                     //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//                                 James Card                                 //
//                          http://www.jamescard.org                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// Doxygen marker
/// @file

// Custom includes
#include "Filesystem.h"

/// @struct FilesystemState
///
/// @brief State metadata the filesystem process uses to provide access to
/// files.
///
/// @param sdFat An SdFat object as defined by the SdFat library.
typedef struct FilesystemState {
  SdFat sdFat;
} FilesystemState;

/// @typedef FilesystemCommandHandler
///
/// @brief Definition of a filesystem command handler function.
typedef int (*FilesystemCommandHandler)(FilesystemState*, ProcessMessage*);

/// @def PIN_SD_CS
///
/// @brief Pin to use for the MicroSD card reader's SPI chip select line.
#define PIN_SD_CS 4

/// @var sdCardErrors
///
/// @brief Array of error strings that correspond to error codes generated by
/// the SdFat library.
const static char *sdCardErrors[] = {
  "No error",
  "Card reset failed",
  "SDIO read CID",
  "SDIO publish RCA",
  "Switch card function",
  "SDIO card select",
  "Send and check interface settings",
  "Read CSD data",
  "Read CID data",
  "Stop multiple block transmission",
  "Read card status",
  "Read single block",
  "Read multiple blocks",
  "Write single block",
  "Write multiple blocks",
  "Set first erase block",
  "Set last erase block",
  "Erase selected blocks",
  "Read OCR register",
  "Set CRC mode",
  "Set SDIO bus width",
  "Read extended status",
  "Set pre-erased count",
  "Activate card initialization",
  "Read SCR data",
  "Bad read data token",
  "Read CRC error",
  "SDIO fifo read timeout",
  "Read CID or CSD failed.",
  "Bad readStart argument",
  "Read data timeout",
  "Multiple block stop failed",
  "SDIO transfer complete",
  "Write data not accepted",
  "SDIO fifo write timeout",
  "Bad writeStart argument",
  "Flash programming",
  "Write timeout",
  "DMA transfer failed",
  "Card did not accept erase commands",
  "Card does not support erase",
  "Erase command timeout",
  "Card has not been initialized",
  "Invalid card config",
  "Unsupported SDIO command",
};

/// @fn void filesystemPrintError(FilesystemState *filesystemState)
///
/// @brief Print out the current error status of the filesystem state.
///
/// @param filesystemState A pointer to the FilesystemState object maintained
///   by the filesystem process.
///
/// @return This function returns no value.
void filesystemPrintError(FilesystemState *filesystemState) {
  uint8_t errorCode = filesystemState->sdFat.card()->errorCode();
  uint8_t errorData = filesystemState->sdFat.card()->errorData();

  Serial.print("SD initialization failed. Error Code: 0x");
  Serial.print(errorCode, HEX);
  Serial.print(" Error Data: 0x");
  Serial.println(errorData, HEX);
  Serial.println(sdCardErrors[errorCode]);
  
  return;
}

/// @fn int filesystemOpenFileCommandHandler(
///   FilesystemState *filesystemState, ProcessMessage *processMessage)
///
/// @brief Command handler for FILESYSTEM_OPEN_FILE command.
///
/// @param filesystemState A pointer to the FilesystemState object maintained
///   by the filesystem process.
/// @param processMessage A pointer to the ProcessMessage that was received by
///   the filesystem process.
///
/// @return Returns 0 on success, a standard POSIX error code on failure.
int filesystemOpenFileCommandHandler(
  FilesystemState *filesystemState, ProcessMessage *processMessage
) {
  (void) filesystemState;

  const char *pathname = nanoOsMessageDataPointer(processMessage, char*);
  const char *modeString = nanoOsMessageFuncPointer(processMessage, char*);
  int mode = 0;
  if ((strchr(modeString, 'r') && (strchr(modeString, 'w')))
    || (strchr(modeString, '+'))
  ) {
    mode |= O_RDWR;
  } else if (strchr(modeString, 'r')) {
    mode |= O_RDONLY;
  } else if (strchr(modeString, 'w')) {
    mode |= O_WRONLY;
  }
  if (strchr(modeString, 'w')) {
    mode |= O_CREAT | O_TRUNC;
  } else if (strchr(modeString, 'a')) {
    mode |= O_APPEND | O_CREAT;
  }

  NanoOsFile *nanoOsFile = (NanoOsFile*) malloc(sizeof(NanoOsFile));
  nanoOsFile->sdFile = new SdFile(pathname, mode);
  NanoOsMessage *nanoOsMessage
    = (NanoOsMessage*) processMessageData(processMessage);
  nanoOsMessage->data = (intptr_t) nanoOsFile;
  processMessageSetDone(processMessage);
  return 0;
}

/// @var filesystemCommandHandlers
///
/// @brief Array of FilesystemCommandHandler function pointers.
FilesystemCommandHandler filesystemCommandHandlers[] = {
  filesystemOpenFileCommandHandler, // FILESYSTEM_OPEN_FILE
};

/// @fn void* runFilesystem(void *args)
///
/// @brief Process entry-point for the filesystem process.  Sets up and
/// configures access to the SD card reader and then enters an infinite loop
/// for processing commands.
///
/// @param args Any arguments to this function, cast to a void*.  Currently
///   ignored by this function.
///
/// @return This function never returns, but would return NULL if it did.
void* runFilesystem(void *args) {
  (void) args;
  ProcessMessage *schedulerMessage = NULL;

  FilesystemState filesystemState;
  if (!filesystemState.sdFat.begin(PIN_SD_CS, SPI_HALF_SPEED)) {
    printString("ERROR! Could not initialize SdFat library!\n");
    filesystemPrintError(&filesystemState);
  }

  while (1) {
    schedulerMessage = (ProcessMessage*) coroutineYield(NULL);
    if (schedulerMessage != NULL) {
      // We have a message from the scheduler that we need to process.  This
      // is not the expected case, but it's the priority case, so we need to
      // list it first.
      FilesystemCommandResponse messageType
        = (FilesystemCommandResponse) processMessageType(schedulerMessage);
      if (messageType < NUM_FILESYSTEM_COMMANDS) {
        filesystemCommandHandlers[messageType](
          &filesystemState, schedulerMessage);
      } else {
        printString("ERROR!!!  Received unknown filesystem command ");
        printInt(messageType);
        printString(" from scheduler.\n");
      }
    }
  }

  return NULL;
}

/// @fn FILE* filesystemFOpen(const char *pathname, const char *mode)
///
/// @brief NanoOs implementation of standard fopen command.
///
/// @param pathname Pointer to a C string with the full path to the file to
///   open.
/// @param mode Pointer to a C string containing one of the standard file mode
///   combinations.
///
/// @return Returns a pointer to a newly-allocated and initialized FILE object
/// on success, NULL on failure.
FILE* filesystemFOpen(const char *pathname, const char *mode) {
  ProcessMessage *processMessage = sendNanoOsMessageToPid(
    NANO_OS_FILESYSTEM_PROCESS_ID, FILESYSTEM_OPEN_FILE,
    /* func= */ (intptr_t) mode, /* data= */ (intptr_t) pathname, true);
  processMessageWaitForDone(processMessage, NULL);
  FILE *returnValue = nanoOsMessageDataPointer(processMessage, FILE*);
  processMessageRelease(processMessage);
  return returnValue;
}

/// @fn int filesystemFClose(FILE *stream)
///
/// @brief Close a file previously opened with filesystemFOpen.
///
/// @param stream A pointer to the FILE object that was previously opened.
///
/// @return Returns 0 on success, EOF on failure.  On failure, the value of
/// errno is also set to the appropriate error.
int filesystemFClose(FILE *stream) {
  (void) stream;
  return 0;
}

